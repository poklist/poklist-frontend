# ListSection 組件設計分析

## 整體設計思路

### 懶加載機制

- 使用 `isVisible` 狀態控制內容是否可見
- 依賴 IntersectionObserver 監測組件是否進入視口
- 僅當可見時才執行數據請求，減少不必要的網絡請求

### 返回訪問優化

- 使用 sessionStorage 記錄訪問狀態 (`SESSION_VISITED_KEY`)
- 返回訪問時直接設置 `isVisible = true`，繞過懶加載機制
- 設計目的：避免與瀏覽器的 ScrollRestoration 功能衝突

### 類別分組與展開機制

- 資料按類別分組展示
- 初始顯示較少內容 (`INITIAL_DISPLAY_COUNT = 5`)
- 通過 "See more" 按鈕展開更多內容 (`EXPANDED_DISPLAY_COUNT = 10`)
- 展開狀態保存在 UIStore 中，實現狀態持久化

## 優勢與限制

### 優勢

- 減少首次訪問時不必要的數據加載，提升效能
- 解決滾動恢復與懶加載衝突問題
- 模塊化和組件化設計，職責劃分清晰

### 限制

1. **內容更新處理不夠完善**

   - 返回訪問時直接顯示內容，若數據有更新會有短暫的"內容跳變"
   - 缺乏基於內容ID的定位復原機制

2. **懶加載粒度較粗**

   - 目前是整體懶加載，無法針對分類實現更細粒度控制
   - 對於長頁面，仍可能載入過多不可見內容

3. **用戶瀏覽痕跡較少**
   - 僅記錄有無訪問，未記錄具體查看的內容

## 未來優化方向

### 1. 混合滾動位置恢復策略

- 結合內容ID與滾動位置的雙重恢復機制
- 記錄用戶最後查看的特定內容，返回時優先定位到該內容

### 2. 虛擬列表實現

- 對於長列表，考慮引入 React Virtualized 或 React Window
- 僅渲染可視區域的內容，提升渲染效能

### 3. 分段式懶加載

- 按類別實現更細粒度的懶加載
- 可使用單獨的 IntersectionObserver 監測每個類別區域

### 4. 更完善的數據緩存策略

- 結合 SWR 或 React Query 實現更智能的緩存
- 實現返回訪問時的快速顯示與後台更新

### 5. 用戶行為分析增強

- 記錄用戶查看內容的時間及行為
- 基於這些數據實現更個性化的內容推薦

## 參考大型社群應用的設計啟示

大型社群應用如Instagram在處理返回訪問和懶加載時通常採用：

- **基於內容ID的位置恢復**：不只依賴滾動位置，而是記住內容標識
- **虛擬列表/窗口化渲染**：只渲染視窗內和周邊內容
- **智能內容緩存**：內存中緩存已查看內容，返回時優先使用
- **漸進式加載**：先顯示低解析度或佔位圖像
- **分段式滾動恢復**：先快速滾動到大致位置，再微調至精確位置

這些策略可作為ListSection組件未來優化的參考方向。
